1. Array smashing
itvSem.ml 에서 resolve_offset
- x[3]이 들어와도 x[*] 로 퉁친다. index는 무시하고
array의 모든 element를 하나의 요약값으로 요약하겠다는 이야기

예) 
concrete memory가
x[0] |-> 1, x[1] |-> 3, x[2] |-> 5 일 때 
abstract memory는
x[*] |-> [1,5] 로 요약한다.

예2)
포인터가 있으니까.
if (e) {
 p = &x;
} else {
 p = &y;
}
p[1] = 2;
를 실행했을 때
`x[*]`에도 2를 넣고 `y[*]`에도 2를 넣어야 하잖음? if문이 true쪽이나 false 쪽이나 어느쪽으로 실행될지 모르니까. p[1]은 `{x[*], y[*]}`로 evaluate되어야 하는 거임. 

2. 
proven은 알람 아닌거 (안전함이 증명됨)
unproven은 알람인거 (증명 안됨)
query는 배열 접근 들

3.
allocation site
malloc을 하면 주소가 나올 거잖아. 그런데 그 주소를 요약하고 싶잖아.
"malloc하는 프로그램 위치"로 요약하는 거야.
for (...;...;...) { p = malloc(...); }
malloc이 for문 안에 있으면 malloc이 여러번 불릴 거잖아.
그러면 주소가 여러 개 나올 거잖아.
그 주소들을 모조리 "malloc하는 프로그램 위치"로 요약하려는 것임.
즉, malloc하면 나오는 힙 메모리 영역의 시작주소를 코드상에서 나타는 위치로 요약한다는 뜻.
즉, 실제세계에서는  malloc을 여러번 하면 할당된 메모리 영역의 시작 주소들이 다르지만 요약세계에서는 그 주소들을 모조리 line 6으로 요약한다

4.
query 는 말그대로 분석기에게 질문한 개수인데 buffer overrun 경우엔
a[i] = 1;  <= 이런경우  “a 의 크기가 i 보다 큰가?”  이것을 질문 하나로 치거든.  즉, 버퍼 접근 안전성을 묻는 질문의 개수이다.
그런데

if(*)
  p = malloc(s1);
else
  p = malloc(s2);

*(p + i)  <=  이런 경우엔 p 가 두가지 버퍼를 가리키게 되니까 질문이 두개가 되겠지? 그래서, 여기서 #queries 는 총 두개.

#queries mod alarm point 는 저런 상황 생각하지 않고, 프로그램 syntax 에서 등장하는 개수를 세는거지.
위에 내가 쓴 코드 같은 경우엔 그래서 #queries 는 두개지만 #query mod alarm point 는 하나가 되겠지.



